(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{218:function(a,s,e){"use strict";e.r(s);var t=e(0),n=Object(t.a)({},function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"_3-4-4-函数式编程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-4-函数式编程","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.4.4 函数式编程")]),a._v(" "),e("h2",{attrs:{id:"介绍："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍：","aria-hidden":"true"}},[a._v("#")]),a._v(" 介绍：")]),a._v(" "),e("ul",[e("li",[a._v("与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。")]),a._v(" "),e("li",[a._v("最主要的特征是，函数是第一等公民。")]),a._v(" "),e("li",[a._v("强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成 MapReduce 算法。")]),a._v(" "),e("li",[a._v("只有纯的、没有副作用的函数，才是合格的函数。")])]),a._v(" "),e("h2",{attrs:{id:"函数式编程有两个最基本的运算：合成和柯里化。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程有两个最基本的运算：合成和柯里化。","aria-hidden":"true"}},[a._v("#")]),a._v(" 函数式编程有两个最基本的运算：合成和柯里化。")]),a._v(" "),e("h2",{attrs:{id:"函数的合成与柯里化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数的合成与柯里化","aria-hidden":"true"}},[a._v("#")]),a._v(" 函数的合成与柯里化")]),a._v(" "),e("ul",[e("li",[a._v('要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做"函数的合成"（compose）。')]),a._v(" "),e("li",[a._v('所谓"柯里化"，就是把一个多参数的函数，转化为单参数函数。')])]),a._v(" "),e("h2",{attrs:{id:"函子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函子","aria-hidden":"true"}},[a._v("#")]),a._v(" 函子")]),a._v(" "),e("blockquote",[e("p",[a._v("是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位")])]),a._v(" "),e("h3",{attrs:{id:"函子的代码实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函子的代码实现","aria-hidden":"true"}},[a._v("#")]),a._v(" 函子的代码实现")]),a._v(" "),e("p",[a._v("任何具有map方法的数据结构，都可以当作函子的实现。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class Functor {\n  constructor(val) { \n    this.val = val; \n  }\n\n  map(f) {\n    return new Functor(f(this.val));\n  }\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br")])]),e("blockquote",[e("p",[a._v("函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器")])]),a._v(" "),e("blockquote",[e("p",[a._v("学习函数式编程，实际上就是学习函子的各种运算")])]),a._v(" "),e("h2",{attrs:{id:"of"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#of","aria-hidden":"true"}},[a._v("#")]),a._v(" of")]),a._v(" "),e("p",[a._v("函数式编程一般约定，函子有一个of方法，用来生成新的容器。")]),a._v(" "),e("p",[a._v("下面就用of方法替换掉new。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Functor.of = function(val) {\n  return new Functor(val);\n};\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h2",{attrs:{id:"maybe-函子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#maybe-函子","aria-hidden":"true"}},[a._v("#")]),a._v(" Maybe 函子")]),a._v(" "),e("blockquote",[e("p",[a._v("函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），"),e("br"),a._v("\n而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Functor.of(null).map(function (s) {\n  return s.toUpperCase();\n});\n// TypeError\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])]),e("p",[a._v("上面代码中，函子里面的值是null，结果小写变成大写的时候就出错了。")]),a._v(" "),e("p",[a._v("Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class Maybe extends Functor {\n  map(f) {\n    return this.val ? Maybe.of(f(this.val)) : Maybe.of(null);\n  }\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("h2",{attrs:{id:"either-函子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#either-函子","aria-hidden":"true"}},[a._v("#")]),a._v(" Either 函子")]),a._v(" "),e("p",[a._v("条件运算if...else是最常见的运算之一，函数式编程里面，使用 Either 函子表达。")]),a._v(" "),e("p",[a._v("Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("\nvar addOne = function (x) {\n  return x + 1;\n};\n\nEither.of(5, 6).map(addOne);\n// Either(5, 7);\n\nEither.of(1, null).map(addOne);\n// Either(2, null);\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br")])]),e("h2",{attrs:{id:"ap-函子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ap-函子","aria-hidden":"true"}},[a._v("#")]),a._v(" ap 函子")]),a._v(" "),e("blockquote",[e("p",[a._v("函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。")])]),a._v(" "),e("blockquote",[e("p",[a._v("ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。")])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("class Ap extends Functor {\n  ap(F) {\n    return Ap.of(this.val(F.val));\n  }\n}\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("p",[a._v("注意，ap方法的参数不是函数，而是另一个函子。")]),a._v(" "),e("h2",{attrs:{id:"monad-函子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#monad-函子","aria-hidden":"true"}},[a._v("#")]),a._v(" Monad 函子")]),a._v(" "),e("blockquote"),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("Maybe.of(\n  Maybe.of(\n    Maybe.of({name: 'Mulburry', number: 8402})\n  )\n)\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("p",[a._v("上面这个函子，一共有三个Maybe嵌套。如果要取出内部的值，就要连续取三次this.val。这当然很不方便，因此就出现了 Monad 函子。")]),a._v(" "),e("p",[a._v("Monad 函子的作用是，总是返回一个单层的函子。它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，"),e("br"),a._v("\n它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。")]),a._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html#%E4%BB%8B%E7%BB%8D",target:"_blank",rel:"noopener noreferrer"}},[a._v("JS 函数式编程指南"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("函数式编程入门教程"),e("OutboundLink")],1)])])])},[],!1,null,null,null);s.default=n.exports}}]);