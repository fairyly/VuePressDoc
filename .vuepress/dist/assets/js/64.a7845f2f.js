(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{291:function(t,r,e){"use strict";e.r(r);var a=e(0),s=Object(a.a)({},function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_3-1-5-作用域链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-5-作用域链","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.1.5 作用域链")]),t._v(" "),e("h1",{attrs:{id:"作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域","aria-hidden":"true"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),e("p",[t._v("作用域是程序源代码中定义变量的区域。")]),t._v(" "),e("p",[t._v("作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。")]),t._v(" "),e("blockquote",[e("p",[t._v("说到作用域，js 分为词法作用域（静态作用域）和动态作用域")])]),t._v(" "),e("ul",[e("li",[t._v("词法作用域：函数的作用域在函数定义的时候就决定了。")]),t._v(" "),e("li",[t._v("动态作用域，函数的作用域是在函数调用的时候才决定的。")])]),t._v(" "),e("h2",{attrs:{id:"作用域链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域链","aria-hidden":"true"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),e("blockquote",[e("p",[t._v("当查找变量的时候，会先从当前上下文的变量对象中查找，"),e("br"),t._v("\n如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。"),e("br"),t._v("\n这样由多个执行上下文的变量对象构成的链表就叫做作用域链。")])]),t._v(" "),e("p",[t._v("对于每个执行上下文，都有三个重要属性：")]),t._v(" "),e("ul",[e("li",[t._v("变量对象(Variable object，VO)")]),t._v(" "),e("li",[t._v("作用域链(Scope chain)")]),t._v(" "),e("li",[t._v("this")])]),t._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/3",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript深入之词法作用域和动态作用域"),e("OutboundLink")],1)]),t._v(" "),e("li",[e("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/6",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript深入之作用域链"),e("OutboundLink")],1)])])])},[],!1,null,null,null);r.default=s.exports}}]);