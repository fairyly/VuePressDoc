(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{187:function(e,t,o){"use strict";o.r(t);var n=o(0),r=Object(n.a)({},function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"_1-3-1-purecomponent-和-component"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-1-purecomponent-和-component","aria-hidden":"true"}},[e._v("#")]),e._v(" 1.3.1 PureComponent 和 Component")]),e._v(" "),o("blockquote",[o("p",[e._v("React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过prop和state的浅对比来实现 shouldComponentUpate()")])]),e._v(" "),o("h2",{attrs:{id:"component"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#component","aria-hidden":"true"}},[e._v("#")]),e._v(" Component")]),e._v(" "),o("blockquote",[o("p",[e._v("Component不会比较当前和下个状态的props和state,"),o("br"),e._v("\n因此，每当shouldComponentUpdate被调用时，组件默认的会重新渲染。")])]),e._v(" "),o("h2",{attrs:{id:"purecomponent"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent","aria-hidden":"true"}},[e._v("#")]),e._v(" PureComponent")]),e._v(" "),o("blockquote",[o("p",[e._v("不需要开发者自己实现shouldComponentUpdate，就可以进行简单的判断来提升性能")])]),e._v(" "),o("blockquote",[o("p",[e._v("在PureComponent中，如果包含比较复杂的数据结构，可能会因深层的数据不一致而产生错误的否定判断，导致界面得不到更新。")])]),e._v(" "),o("blockquote",[o("p",[e._v("浅对比只是用Object.is()对Object的value做了一个基本数据类型的比较。")])]),e._v(" "),o("h2",{attrs:{id:"参考"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),o("ul",[o("li",[o("a",{attrs:{href:"https://github.com/zpao/qrcode.react/blob/master/src/index.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("qrcode.react 源码"),o("OutboundLink")],1)]),e._v(" "),o("li",[o("a",{attrs:{href:"https://blog.csdn.net/u013003052/article/details/87894262",target:"_blank",rel:"noopener noreferrer"}},[e._v("Component和PureComponent的区别"),o("OutboundLink")],1)])])])},[],!1,null,null,null);t.default=r.exports}}]);