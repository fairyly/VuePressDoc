(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{254:function(t,a,r){"use strict";r.r(a);var e=r(0),n=Object(e.a)({},function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"_3-3-8-尾调用优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-8-尾调用优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.3.8 尾调用优化")]),t._v(" "),r("blockquote",[r("p",[t._v("尾调用优化 Tail Call Optimisation")])]),t._v(" "),r("blockquote",[r("p",[t._v("就是指某个函数的最后一步是调用另一个函数。")])]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("function f(x){\n  return g(x);\n}\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br")])]),r("blockquote",[r("p",[t._v("是调用函数之后，还有别的操作，都不属于尾调用")])]),t._v(" "),r("blockquote",[r("p",[t._v("尾调用不一定出现在函数尾部，只要是最后一步操作即可。")])]),t._v(" "),r("h2",{attrs:{id:"尾调用优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#尾调用优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 尾调用优化")]),t._v(" "),r("blockquote",[r("p",[t._v('函数调用会在内存形成一个"调用记录"，又称"调用帧"（call frame），保存调用位置和内部变量等信息。'),r("br"),t._v("\n如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。"),r("br"),t._v("\n等到B运行结束，将结果返回到A，B的调用记录才会消失。"),r("br"),t._v("\n如果函数B内部还调用函数C，那就还有一个C的调用记录栈，以此类推。"),r("br"),t._v('\n所有的调用记录，就形成一个"调用栈"（call stack）。')])]),t._v(" "),r("p",[r("img",{attrs:{src:"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015041002.png",alt:""}})]),t._v(" "),r("blockquote",[r("p",[t._v('"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。'),r("br"),t._v("\n如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。"),r("br"),t._v('\n这就是"尾调用优化"的意义。')])]),t._v(" "),r("h2",{attrs:{id:"尾递归"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#尾递归","aria-hidden":"true"}},[t._v("#")]),t._v(" 尾递归")]),t._v(" "),r("blockquote",[r("p",[t._v("函数调用自身，称为递归。如果尾调用自身，就称为尾递归。")])]),t._v(" "),r("blockquote",[r("p",[t._v('递归非常耗费内存，因为需要同时保存成千上百个调用记录，很容易发生"栈溢出"错误（stack overflow）。'),r("br"),t._v('\n但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生"栈溢出"错误。')])]),t._v(" "),r("h2",{attrs:{id:"柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。","aria-hidden":"true"}},[t._v("#")]),t._v(" 柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。")]),t._v(" "),r("blockquote",[r("p",[t._v('对于其他支持"尾调用优化"的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。')])]),t._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2015/04/tail-call.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("尾调用优化"),r("OutboundLink")],1)]),t._v(" "),r("li",[r("a",{attrs:{href:"https://segmentfault.com/a/1190000004018047",target:"_blank",rel:"noopener noreferrer"}},[t._v("[翻译] JS的递归与TCO尾调用优化"),r("OutboundLink")],1)])])])},[],!1,null,null,null);a.default=n.exports}}]);