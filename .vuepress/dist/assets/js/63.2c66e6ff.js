(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{289:function(a,s,e){"use strict";e.r(s);var n=e(0),t=Object(n.a)({},function(){var a=this,s=a.$createElement,e=a._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"_3-1-4-js堆栈池"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-4-js堆栈池","aria-hidden":"true"}},[a._v("#")]),a._v(" 3.1.4  JS堆栈池")]),a._v(" "),e("blockquote"),a._v(" "),e("h3",{attrs:{id:"内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存模型","aria-hidden":"true"}},[a._v("#")]),a._v(" #内存模型")]),a._v(" "),e("p",[a._v("JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。")]),a._v(" "),e("p",[a._v("为了更好的搞懂栈内存与堆内存，我们可以结合以下例子与图解进行理解。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a1 = 0; // 栈 \nvar a2 = 'this is string'; // 栈\nvar a3 = null; // 栈 \nvar b = { m: 20 }; // 变量b存在于栈中，{m: 20} 作为对象存在于堆内存中\nvar c = [1, 2, 3]; // 变量c存在于栈中，[1, 2, 3] 作为对象存在于堆内存中\n\n作者：梁音\n链接：https://juejin.im/post/5b10ba336fb9a01e66164346\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br")])]),e("h3",{attrs:{id:"内存的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存的生命周期","aria-hidden":"true"}},[a._v("#")]),a._v(" #内存的生命周期")]),a._v(" "),e("p",[a._v("JS环境中分配的内存一般有如下生命周期：")]),a._v(" "),e("ul",[e("li",[a._v("内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存")]),a._v(" "),e("li",[a._v("内存使用：即读写内存，也就是使用变量、函数等")]),a._v(" "),e("li",[a._v("内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存")])]),a._v(" "),e("p",[a._v("为了便于理解，我们使用一个简单的例子来解释这个周期。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var a = 20;  // 在内存中给数值变量分配空间\nalert(a + 100);  // 使用内存\nvar a = null; // 使用完毕之后，释放内存空间\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br")])]),e("h3",{attrs:{id:"内存回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存回收","aria-hidden":"true"}},[a._v("#")]),a._v(" #内存回收")]),a._v(" "),e("h3",{attrs:{id:"垃圾回收算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法","aria-hidden":"true"}},[a._v("#")]),a._v(" #垃圾回收算法")]),a._v(" "),e("ul",[e("li",[a._v("引用计数算法\n"),e("ul",[e("li",[a._v("引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。")])])]),a._v(" "),e("li",[a._v("标记清除算法\n"),e("ul",[e("li",[a._v("现代的浏览器已经不再使用引用计数算法了。现代浏览器通用的大多是基于标记清除算法的某些改进算法，总体思想都是一致的")]),a._v(" "),e("li",[a._v("标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。")]),a._v(" "),e("li",[a._v("凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。")])])])]),a._v(" "),e("h3",{attrs:{id:"内存泄露"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存泄露","aria-hidden":"true"}},[a._v("#")]),a._v(" #内存泄露")]),a._v(" "),e("ul",[e("li",[a._v("不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。")])]),a._v(" "),e("h4",{attrs:{id:"内存泄漏的识别方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏的识别方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 内存泄漏的识别方法")]),a._v(" "),e("ul",[e("li",[a._v("浏览器方法")])]),a._v(" "),e("p",[a._v("打开开发者工具，选择 Timeline 面板"),e("br"),a._v("\n在顶部的Capture字段里面勾选 Memory"),e("br"),a._v("\n点击左上角的录制按钮。"),e("br"),a._v("\n在页面上进行各种操作，模拟用户的使用情况。"),e("br"),a._v("\n一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。")]),a._v(" "),e("p",[a._v("如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。"),e("br"),a._v("\n反之，就是内存泄漏了。")]),a._v(" "),e("ul",[e("li",[a._v("命令行方法")])]),a._v(" "),e("p",[a._v("命令行可以使用 Node 提供的 process.memoryUsage 方法。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("console.log(process.memoryUsage());\n// { rss: 27709440,\n//  heapTotal: 5685248,\n//  heapUsed: 3449392,\n//  external: 8772 }\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br")])]),e("p",[a._v("process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，含义如下。")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('Resident Set(常驻内存)\n\nCode Segment(代码区)\n\nStack(Local Variables, Pointers)\n\nHeap(Objects, Closures)\n\nUsed Heap\n\n\nrss（resident set size）：所有内存占用，包括指令区和堆栈。\nheapTotal："堆"占用的内存，包括用到的和没用到的。\nheapUsed：用到的堆的部分。\nexternal： V8 引擎内部的 C++ 对象占用的内存。\n')])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br")])]),e("p",[a._v("判断内存泄漏，以heapUsed字段为准。")]),a._v(" "),e("h2",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[a._v("#")]),a._v(" #参考资料")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("http://www.ruanyifeng.com/blog/2017/04/memory-leak.html")])]),a._v(" "),e("li",[e("p",[a._v("https://juejin.im/post/5b10ba336fb9a01e66164346")])]),a._v(" "),e("li",[e("p",[a._v("https://www.jianshu.com/p/84a8fd5fa0ee")])]),a._v(" "),e("li",[e("p",[e("a",{attrs:{href:""}})])])])])},[],!1,null,null,null);s.default=t.exports}}]);